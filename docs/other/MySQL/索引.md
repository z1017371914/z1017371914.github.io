## 索引

1.`索引`：类似于字典目录，为了提高查询效率而出现。

2.`索引模型`：**哈希表**，**有序数组**，**搜索树**

3.`哈希表`：以键值对的形式存储数据。key：字段的某个值，value：该行记录的位置。

![image](https://tvax1.sinaimg.cn/large/0085EwgIgy1gtdazpfafgj60ob0iqae302.jpg)

`优点`：哈希冲突少的情况下，查询速度快

`缺点`：无法进行**范围查询**，只能用于**等值查询**

4.`有序数组`：

![image](https://tvax3.sinaimg.cn/large/0085EwgIgy1gtdb02otpkj60p50hkdiw02.jpg)

`优点`：可以通过二分法来快速定位查询的位置

`缺点`：维护有序性成本非常高，涉及到内存重分配

`应用场景`：静态数据的存储，改动次数不多的场景

---



### InnoDB的索引模型

1.`InnoDB索引模型`：**B+树**

2.`例子`：我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树
的示例示意图如下

![image](https://tvax2.sinaimg.cn/large/0085EwgIgy1gtdb5r2j6uj60o50i40w502.jpg)

左边的以主键为索引，称为`主键索引`，或者`聚簇索引`；

右边的以非主键为索引，称为`非主键索引`，或者`二级索引`。二级索引存的是主键的位置，需要取该行的值时，需要再通过主键索引才能定位到行的位置。这个过程称为`回表`

### 覆盖索引

1.`出现的原因`：为了减少回表操作，产生了`覆盖索引`。

2.`覆盖索引`：顾名思义，将需要查询的记录做成索引，而不用再依赖于主键索引回表操作才能取出对应的字段。就比如需要查询A，B这两个非主键字段，可以建立(A,B)这样的索引。这就是覆盖索引。

### 最左前缀原则

1.`最左前缀原则`：建立了(a,b)联合索引，在查询时会先通过a，再通过b来定位。如果先用b来查询，那么(a，b)索引不会生效。

2.`如何安排索引的顺序`：因为最左前缀原则，导致了我们需要考虑怎么安排索引内的字段顺序。一般我们有了(a,b)联合索引，就不会再建a索引。如果还有b的单独查询，那就只能建立(a, b)，(b)两个索引。

### 索引下推

1.`索引下推`：当联合索引不完全匹配时，以前的操作时只能从不满足的地方慢慢的遍历，然后回表。

![image](https://tva4.sinaimg.cn/large/0085EwgIgy1gtdblryglrj60o80ihdjb02.jpg)

例如查找name like '张%' and age = 10 and ismale = 1

此时我们的联合索引只有name是起作用的，而后面的不能生效。于是就只能定位到张六开始，遍历所有为张的行记录，得到ID，然后通过ID进行回表操作。

2.`索引下推带来的不同`：上述情况进行了很多次回表操作。而索引下推能减少一定程度上的回表。

![image](https://tvax1.sinaimg.cn/large/0085EwgIgy1gtdbpaib52j60nz0huadi02.jpg)

索引虽然在name后就不生效，但是索引下推还是会继续往下一位寻找来过滤掉不必要的回表操作：张六符合但age != 10，舍弃； 张三符合且age = 10，取其ID进行回表。

