## 一致性视图

1.`一致性视图`：Consistent read view，用于支持读提交和可重复读这两个隔离级别的实现

下面需要关注`查询`和`更新`时，是如何实现一致性视图的。

### 查询时的"快照"

1.`快照`：在可重复读的隔离级别下，事务启动时就进行了"快照"一样的操作，使得事务能看到的数据不受其他数据的影响。

2.`问题`：如果真的是进行实际的快照，每个事务启动都全盘拷贝数据，那也太逆天了。所以这儿的快照不是传统意义上的，而是通过其他机制来实现。

3.`具体实现`：

- 每个事务有唯一的事务ID，称为transaction ID
- 每个行数据会有多个版本，也就是所谓的MVCC。每个事务进行更新时，都会将事务的transactionID赋给行数据的row trx_id

![image](https://tva1.sinaimg.cn/large/0085EwgIgy1gtehhj9pfnj60nn0hlwib02.jpg)

如图这一行有很多个版本v1，v2，v3... 版本之间的row trx_id不一样，其row trx_id对应修改它的事务ID。

- 每个事务启动的时候，有一个数组记录所有正在`活跃`(启动了但尚未提交的事务)的事务ID
- 通过上面的事务ID，将数组分成了低水位和高水位。

![image](https://tvax1.sinaimg.cn/large/0085EwgIgy1gtehlq043bj60n90hntai02.jpg)

- 假设当前事务的事务ID为100，低水位的事务ID为90，高水位的事务ID为110。

  - 对于0-89的事务就是已经提交的事务，对当前事务100是完全可见的
  - 对于110往后的事务ID，对当前事务100是完全不可见的
  - 如果改行的row trx_id在90 - 110内，那么说明该版本的数据并没有执行结束(事务未提交)，对于事务100来说是不可见的
  - 如果该行的row trx_id不在90 - 110内，那么说明该版本的数据是已经提交的事务生成的，对于事务100来说是可见的。

  **这样就实现了查询时的''快照''功能**

  4.`概括`：简而言之：

  - 行数据的版本未提交，对当前事务不可见
  - 行数据的版本在创建视图前提交，对当前事务可见
  - 行数据的版本在创建视图后提交，对当前事务不可见

### 更新的逻辑

1.事务进行更新操作时，需要进行：读数据，更新数据。

- `读数据`：需要实现当前读，也就是读取到最新的数据
- `更新数据`：当读取到最新数据后，在最新的数据上进行更新。如果当前的记录的行锁被其他事务占有，就只能进入锁等待。

