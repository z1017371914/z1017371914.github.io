## 优化器的执行逻辑

1.`问题`：MySQL建立了索引，有时候查询却没有用到索引，而是全表查询

2.`原因`：优化器执行时，有可能会不选择索引，所以需要探讨一下优化器的执行过程。

 3.`扫描行数`：选择索引的重要判断依据是，需要扫描的行数，因为这决定到需要访问磁盘的次数。

那么优化器如何判断需要扫描的行数呢？MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据`统计信息`来估算记录数

4.`统计信息`：用来做索引的列上不同的值越多，可以认为索引的区分度就越好。这个不用的值的个数，称为`基数`

5.`如何计算基数`：MySQL不是将该列的所有行都扫描一遍来统计，而是选择`抽样统计`

- 选取N个数据页，统计页面上的不同值然后求均值，乘以这个索引的页面数，得到索引的基数。

6.数据是在不断变化的，那么索引的基数也不可能一成不变，何时触发一轮新的索引的基数计算呢？

- 当变更的数据行好过 1/ M时，会重新计算基数

7.`执行方案的选择标准`：

- 基数
- 普通索引可能基数比较大，但是如果是普通索引，还需要考虑回表操作带来的开销，导致需要扫描的行数可能会非常多

### 索引选择异常和处理

如果建立了索引，发现查询时仍然很慢，很可能就是上面分析的选择了错的索引。

解决方案：

- 使用`force index`来强制使用某个索引进行查找
  - 缺点：可拓展性不强，很有可能索引选择错误只是少部分场景
- 使用`order by`，使得需要进行排序，那么扫描的行数又成了决定查询的因素，这时候MySQL就会选择基数大的索引，从而达到"矫正"的效果
  - 缺点：修改了语义

- 重新评估某个索引是否有需要。不需要的话就将其删除掉了。听起来很可笑，但确实如此。

