## 事务隔离

1.`事务`：一系列操作，不可再分，要么全部成功，要么全部失败。

2.`MySQL对事务的支持`：MySQL对于事务，是通过引擎实现的。InnoDB支持事务，MyISAM就不支持事务。

### 事务隔离级别

1.`事务隔离级别`：读未提交，读提交，可重复读，串行化。

2.`读未提交`：一个事务A对字段X的改变，在事务A未提交时，也能被事务B看到更改

3.`读提交`：一个事务A对字段X的改变，在事务A未提交时，不能被事务B所感知。只有事务A提交时，事务B才能看到X的变化

4.`可重复读`：一个事务A在执行过程中看到字段X的值，总是和事务A刚启动时X的值一致。也就是说，尽管有事务B对X进行了更改成了`X'`并且提交，事务A在执行期间也不会感知到变化，看到的仍然是`X`。

5.`串行化`：对同一行的记录，写操作会加写锁，读会加读锁。当读写锁冲突时，后续的事务必须等持有锁的事务释放锁，才能进行操作。

6.`InnoDB默认事务级别`：**可重复读**。

7.`可重复读的应用场景`：假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明
细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果

### 事务隔离的实现

1.InnoDB如何实现可重复读？

①可重复读对于每个事务都使用了`视图`(view)。事务执行期间，读取的数据都以视图内的为准。

②MySQL对于每条记录的更新操作，都会记录一条回滚操作。最新的值能通过回滚操作得到之前操作的所有的值。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![image](https://tva1.sinaimg.cn/large/0085EwgIgy1gtdaonwytij60on0g2ju102.jpg)

有了这两个前提条件，就能实现可重复读了：

不同时刻启动的事务，占有的视图是不一样的：比如事务A占有的是read-viewA视图，事务B占有的是read-viewB。。。此时如果有个新的事务C进行了将事务C视图看到的值：4，改成了5。这对于事务A，事务B而言不可见。从而实现了`可重复读`。

2.`MVCC`：多版本并发控制。指的是上面的图，一条记录中，一个字段的值有多个版本的值。

3.`回滚日志的删除时机`：当系统没有比这个回滚日志更早的read-view时，就会将其删除。回滚日志占用的空间比较多，长事务会导致存在非常老的视图，进而导致很多不必要的回滚日志没被删除，占用磁盘的存储空间。