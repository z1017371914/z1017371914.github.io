<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [类加载器](#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8)
  - [双亲委派模型](#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B)
    - [工作过程](#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B)
    - [好处](#%E5%A5%BD%E5%A4%84)
  - [破坏双亲委派模型](#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B)
    - [JDK1.2发布之前](#jdk12%E5%8F%91%E5%B8%83%E4%B9%8B%E5%89%8D)
    - [模型自身缺陷](#%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%BA%AB%E7%BC%BA%E9%99%B7)
    - [追求动态性](#%E8%BF%BD%E6%B1%82%E5%8A%A8%E6%80%81%E6%80%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

**类与类加载器**

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。简单地说：比较两个类是否“相等”，只有在这两个类是否同一类加载器加载的前提下才有意义，否则，即使这两个类来源于同一Class文件，被同一虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

从Java开发人员来看，类加载器可以划分成3个类加载器：

**启动类加载器（Bootstrap ClassLoader）**

启动类加载器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数锁指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到内存中。启动类加载器无法被Java程序直接引用。

**扩展类加载器（Extension ClassLoader）**

这个加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载`<JAVA_HOME>\lib\ext`目录中的，或者被`java.ext.dirs`系统变量指定的路径中的所有类库。开发者可以直接使用这个类库。

**应用程序类加载器（Application ClassLoader）**

这个类加载器由`sun.misc.Launcher$AppClassLoader`实现，它负责加载用户类路径（Classpath）上所指定的类库。开发者可以直接使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

我们的应用程序一般都是由上面3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

## 双亲委派模型

上面说到的3种加载器以及自定义类加载器可以构成如下图所示的这种层次关系，称为类加载器的`双亲委派模型`。

![](../img/07/07_03_01_parents_delegation_model.png)

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。

### 工作过程

如果一个雷加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会才是自己去加载。

### 好处

使用双亲委派模型来阻止类加载器之间的关系，有一个显而易见的好处就是Java累随着它的类加载器一起具备了一种带有优先级的层次关系。一个类总是由最顶层的类加载器去加载，只有当父类加载器无法完成时才会让子类加载器加载，这也保证同一个类不会被多个类加载器加载，保证了Java类型体系中最基础的行为。

## 破坏双亲委派模型

双亲委派模型只是Java设计者推荐给开发者的类加载实现方式，目前Java世界中大部分的类加载器都遵循这个模型。但这也有例外，到目前为止，双亲委派模型主要出现过3次较大规模的“被破坏”情况。

### JDK1.2发布之前

由于双亲委派模型是JDK1.2之后发布的，而类加载器和抽象类`java.lang.ClassLoader`在JDK1.0时代就存在了，所以在发布双亲委派模型时，Java设计者不得不为引入双亲委派模型做一些妥协。为了向前兼容，JDK1.2之后的`java.lang.ClassLoader`添加了一个新的protected方法findClass()，在这之前，用户去继承`java.lang.ClassLoader`的唯一目的就是为了重写loadClass()方法，因此虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。

### 模型自身缺陷

双亲委派模型很好地解决了各个类加载器的基础类的统一问题，但基础类很有可能又会要调用回用户的代码，这时候怎么办？

为了解决这个问题，Java设计团队引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）

### 追求动态性

双亲委派模型第三次被破坏是因为用户对程序动态性的追求而导致。