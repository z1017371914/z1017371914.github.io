

## 内存

### 运行时数据区域

| 名称       | 线程占用     | 是否会OOM |
| ---------- | ------------ | --------- |
| 方法区     | 所有线程共享 | 会        |
| 堆内存     | 所有线程共享 | 会        |
| 虚拟机栈   | 线程私有     | 会        |
| 本地方法栈 | 线程私有     | 会        |
| 程序计数器 | 线程私有     | 不会      |

#### 程序计数器

存储：记录此线程执行到的字节码的地址。

作用：**记录当前指令的位置**，当发生循环，跳转等功能时，需要通过程序计数器来**找到原来发生切换前所执行的指令的地址**

| 线程正在执行的方法   | 程序技术器存放的内容 |
| -------------------- | -------------------- |
| Java方法             | 字节码指令的地址     |
| 本地方法(Native方法) | 空                   |

#### 虚拟机栈

Java方法被执行时，虚拟机栈会创建一个**栈帧**，存放局部变量表，操作数栈，动态连接，方法出口等。

| 栈帧存放内容 | 里面的具体内容                                               |
| ------------ | ------------------------------------------------------------ |
| 局部变量表   | 基本数据类型、引用数据类型的**指针**，returnAddress类型(指向了一条字节码的地址) |
| 操作数栈     | 需要操作的数据                                               |
| 动态连接     |                                                              |
| 方法出口     |                                                              |

| 局部变量表的内容 | 存放的类型       | 个数    |
| ---------------- | ---------------- | ------- |
| short            | 局部变量槽(Slot) | 1个slot |
| int              | slot             | 1       |
| boolean          | slot             | 1       |
| long             | slot             | 2       |
| double           | slot             | 2       |
| ...              | slot             | 1       |

除了long和double占用两个slot(局部变量槽)。

之所以叫做栈帧，是因为java方法执行的过程，就对应一个栈帧从入栈再到弹出栈的过程。

| 溢出类型         | 原因                                           |
| ---------------- | ---------------------------------------------- |
| OutOfStackMemory | 线程申请的栈深度大于虚拟机所允许的最大深度     |
| OutOfMemory      | 栈容量动态扩容，扩容申请不到足够的容量就会发生 |

#### 本地方法栈

| 栈类型     | 运行的内容 |
| ---------- | ---------- |
| 虚拟机栈   | Java方法   |
| 本地方法栈 | Native方法 |

Native方法，简单来说就是不调用java方法接口的方法，可以是c语言的方法。

#### 堆

存放内容：**对象实例**

java中的对象在实例化后申请内存就是在堆中申请内存。

抛出错误：OutOfMemoryError，在对象申请内存无法满足时就会抛出。

#### 方法区

存放的内容：

>1.常量
>
>2.静态变量
>
>3.编译后的代码

## HotSpot

HotSpot是常用的虚拟机。

### 对象创建的过程

>
>
>1.遇到new指令，去常量池定位到类的符号引用(符号引用即用用字符串符号的形式来表示引用，被引用的类、方法或者变量还没有被加载到内存中。直接引用则是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中)
>
>2.检查类的符号引用所代表的类，是否被加载，解析，初始化。如果没有，就要进行类加载
>
>3.完成类加载的检查后，在堆中为新生的对象分配内存。
>
>4.将申请到的内存空间初始化为零值。目的：对象申请后，其中的实例字段即使对象未初始化也能使用。如果使用TLAB来申请内存时，在TLAB中就可以提前进行该初始化操作。
>
>5.初始化对象的属性值。

**分配内存的方法**

| 收集器              | 分配方法 |
| ------------------- | -------- |
| Serial              | 指针碰撞 |
| ParNew              | 指针碰撞 |
| 使用CMS算法的收集器 | 空闲列表 |

**指针碰撞：**将已分配和未分配的内存，通过**指针化成两部分**，分配内存时，通过移动指针即可实现

**空闲列表：**维护一个空闲表，类似于操作系统的页表，记录哪些是可用的。

**分配内存的并发性**

>
>
>分配内存还要考虑并发的安全性！否则可能会出现：A线程申请某一块内存还没来得及确认，B线程马上使用这块内存，这就会导致A线程创建对象失败
>
>解决方法：
>
>​	a.CAS(compare and swap)+失败重试。
>
>​	b.在TLAB中申请内存。具体过程：每个线程都有一个叫做本地线程分配缓冲的区域，是线程初始化时，从堆中获取到的一小部门内存。线程创建对象需要申请内存，首先在TLAB中申请内存，只有当TLAB中无可用空间时，才会在堆中进行同步操作来申请内存。

| 初始化的类型 | 简要描述                                                     |
| ------------ | ------------------------------------------------------------ |
| 所属的类     | 创建的对象，是哪个类的实例                                   |
| 哈希码       | 对象的哈希码，用于快速寻找到对象，在判断对象是否相等时会用到 |
| 分代信息     | 对象被分配到了新生代还是老年代                               |



### 堆中对象的内存布局

分成三部分：对象头(header)，实例数据(Instance Data)，对齐填充(Padding).

| 存放的类型 | 存放的内容                            |
| ---------- | :------------------------------------ |
| 对象头     | 对象运行时的数据；类型指针            |
| 实例数据   | 对象属性的值                          |
| 对齐填充   | 填充，使得对象占的内存是8字节的整数倍 |

#### 对象头

对象头由两部分组成：对象运行时的数据；类型指针。

##### 对象运行时数据

| 存储内容                   |
| -------------------------- |
| 对象的**哈希码(hashCode)** |
| 指向**锁记录的指针**       |
| 指向**重量级锁的指针**     |
| 对象**分代的年龄**         |
| **偏向线程ID**             |

其中这些内容占用的空间是不确定的，可以动态的分配。但是必须是32位或者64位。

##### 类型指针

类型指针：指向它的类型元数据的指针。

作用：通过指针判断对象是哪个类的实例。

#### 实例数据

含义：程序运行时，定义属性的值。

#### 对齐填充

·任何对象的大小都必须是**8字节的整数倍**。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者 2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

### 对象的访问定位

java中使用reference从栈中读取对象的地址，从而实现访问对象。

reference访问有两种方式：句柄访问，直接访问

#### 句柄访问

句柄访问：是指在JAVA堆中，存放**对象实例数据**和**对象内存数据**的指针。当需要访问对象时，要从句柄池中去寻找到对应的指针，才能在实例池中获取到对象。

![image](https://tvax4.sinaimg.cn/large/0085EwgIly1gonwbpffsrj30kb0ao40h.jpg)

**缺点：**所以每一次访问对象，都需要多一次查询才能访问到

**优点：**对象的维护成本低：当对象的内存地址发生了变化时，只需要改变句柄池中对应的指针即可。

#### 直接访问

在堆中直接存放**对象类型数据**的指针。当访问对象时，从堆中寻找对象，并获取到对象类型数据指针，从而能访问对象。

![image](https://tva3.sinaimg.cn/large/0085EwgIly1gonwefvx73j30kh09fgnd.jpg)

**优点:**一次访问即可获取到对象。

**缺点：**维护对象的成本很高：对象地址发生变化时，在堆中需要进行很多操作。

## 对象存活

### 对象存活的判断过程

1.进行第一次可达性分析，标记可能需要杀死的对象

2.对标记的对象进行筛选，看是否被覆盖了finalize()方法

### 对象存活判断方法

#### 引用计数法

**原理：**为每个对象都添加一个引用计数器，每出现一个地方引用了该对象，就让引用计数器加一。

**优点：**实现简单，逻辑清晰

**缺点：**容易发生互相引用，从而出现垃圾收集器无法回收这两个对象的现象。

#### 可达性分析

**原理：**将根对象作为GC Root，作为起始节点，有引用关系的就加一个**引用链**。当需要判断对象是否存活时，只需要判断该对象是否有从它本身到GC Root的引用链。如果没有，就成为不可达，可以被回收。

![image](https://tva1.sinaimg.cn/large/0085EwgIly1gonwodc52xj30oc0fs0vh.jpg)

能作为GC Root的：

| 存储区域   | 类型                                                         |
| ---------- | ------------------------------------------------------------ |
| 虚拟机栈   | 在虚拟机栈中引用的对象                                       |
| 方法区     | 方法区中静态属性引用的对象，常量引用的对象                   |
| 本地方法栈 | Native方法引用的对象                                         |
| Java虚拟机 | JVM内部引用的对象，如**基本类型的对象**，**常见的异常对象，系统的类加载器** |
| ？         | 所有持有同步锁的对象。即Synchronized                         |

## 引用

传统的对象引用关系，只有被引用和未被引用，这对于实际场景的需求来说，分类得很宽泛。例如：我们希望内存充足时，对象没被引用也能保存在内存中，而内存不足时，即使垃圾收集后还是内存不足，对于一些已经被引用的对象，也应该要被杀死。

因此就有了下面的几种更细颗粒度的分类方法。

### 强引用

**定义：**对象的引用很重要，不可以回收掉

**回收时机：**无论什么情况下，只要强引用还存在，垃圾收集器就无法对其进行收集，宁可抛出OutOfMemoryError。

### 软引用

**含义：**一些还有用，但不是必须的对象。

**回收时机：**在系统内存不足时，将这些对象进行回收。

**发生OutOfMemory的情况：**回收之后还是内存不足才会发生

### 弱引用

**含义：**关联的对象不是很重要。

**回收时机：**下一次垃圾回收到来时，一定要将对象进行回收。

可见弱引用是比软引用，引用关系更低级的。

### 虚引用

**作用：**对象是否存在虚引用，完全不影响它的存活时间。它的作用只不过是，在对象被垃圾收集器回收时，能收到一个系统通知

## 垃圾收集

### 分代理论引申

将java堆分成新生代和老年代，分配原则：熬过垃圾收集次数多的就会进入老年代。

分代的优点：每次收集时，只需要收集新生代，熬过的放入老年代即可。那么收集的效率会高很多。

#### 记忆集

>定义：是一种全局的数据结构，将老年代划分成了很多小块，标记哪些块存在着跨代引用。
>
>作用：在发生**新生代收集(Minor GC)**时，从记忆集中寻找存在跨代引用的对象进行可达性分析，用于判断是否需要进行收集。
>
>优点：在发生Minor GC时，如果存在新生代引用老年代，不需要再全部扫描老年代，而是通过查看记忆集就行了。对于新增的内存开销，是值得的。

#### GC分类

| 部分收集(Partial GC) | 全部收集                        |
| -------------------- | ------------------------------- |
| Minor GC：新生代收集 | Full GC：收集整个java堆和方法区 |
| Major GC：老年代收集 |                                 |

### 垃圾收集算法

#### 标记-清除法

**过程：**标记所有需要回收的对象，在垃圾回收到来时，回收被标记的对象

**缺点：**

1.**效率低**。JAVA堆中对象过多时，标记和清除的效率都很低

2.会**产生很多内存碎片**。内存空间不连续，导致大对象无法分配内存空间。

![image](https://tva3.sinaimg.cn/large/0085EwgIly1goo9t2jd3oj30m00ce40c.jpg)

#### 标记-复制法

**过程：**将内存分成两半，只使用其中的半内存，标记存活的对象，在一般内存满的时候，复制存活的对象到另一半空闲的内存，然后将现在的内存全都释放。

**优点：**避免产生内存碎片

**缺点：**

1.**空间利用率低**，只用了一半

2.当多数对象存活时，**复制的开销会很大**

![image](https://tva2.sinaimg.cn/large/0085EwgIly1goo9x95g3qj30m10cgq4p.jpg)

#### 标记-整理法

>**过程：**标记存活的对象，垃圾收集掉不存活的对象时，将存活的对象往内存的同一端移动。
>
>优点：内存碎片消除。
>
>缺点：移动存活的对象，尤其是老年代，这开销非常庞大，同时需要**停止用户所有的程序**，也就是**stop the world**。

## 垃圾收集器

![image](https://tva1.sinaimg.cn/large/0085EwgIgy1gooy6ddkqqj30nw0h9dha.jpg)

### Serial收集器

单线程的收集器，在发生垃圾收集的时候，会导致**Stop the World** ！！

![image](https://tva2.sinaimg.cn/large/0085EwgIly1gooaare9c7j30lx05lgnp.jpg)

### ParNew收集器

多线程版本的Serial收集器。

多线程：指的是多线程的进行垃圾回收，还是**会导致Stop the World**。

**约束：必须配合CMS收集器使用**

![image](https://tvax4.sinaimg.cn/large/0085EwgIly1gooab69qhsj30lv05yaca.jpg)

### Parallel Scavenge收集器

>多线程的进行垃圾回收。但它的特别点在于关注**吞吐量**
>
>吞吐量 = 用户代码运行时间/ (用户代码运行时间+垃圾回收时间)
>
>能控制的参数：
>
>1.新生代的内存大小。这个大小如果过大，就会导致垃圾回收比较慢；过小，导致垃圾回收会很频繁。
>
>2.垃圾回收占总时间的比率。

### Serial Old收集器

Serial收集器的老年代版本，是单线程收集器，使用**标记-整理算法**

![image](https://tvax3.sinaimg.cn/large/0085EwgIly1gooaje0nq3j30m904r75j.jpg)

### Parallel Old收集器

Parallel Scavenge的老年代版本，是多线程收集器，使用**标记-整理算法**

作用：**和Parallel Scavenge配合使用**

![image](https://tvax1.sinaimg.cn/large/0085EwgIly1gooalh7956j30ly06ytap.jpg)

### CMS收集器

**目的：**追求**最短回收停顿**的收集器。

**收集算法：标记-清除**

步骤：**初始标记**->**并发标记**->**重新标记**->**并发清除**

| 步骤名   | 目的                                                         | 是否StopTheWorld | 下一步   |
| -------- | ------------------------------------------------------------ | ---------------- | -------- |
| 初始标记 | 标记GC Root能到达的对象                                      | 是               | 并发标记 |
| 并发标记 | 从GC Root**直接关联的对象**进行遍历，标记被关联的对象        | 否               | 重新标记 |
| 重新标记 | 消除掉并发标记过程中，因用户线程改变而使引用状态发生变化的对象 | 是               | 并发消除 |
| 并发消除 | 并发的清除掉被标记的对象                                     | 否               | 无       |

![image](https://tva3.sinaimg.cn/large/0085EwgIly1gooas9tssqj30m405hq5l.jpg)



>**缺点：**
>
>1.**对CPU资源敏感**。由于分配了一部分线程进行并发标记和并发清除，因此用户的直观感觉会是速度较慢
>
>2.**无法处理浮动垃圾**。浮动垃圾：在并发标记阶段产生的垃圾，CMS是无法在这次收集中处理，只能等待下一次垃圾收集。
>
>3.**会产生内存碎片。**因为它用的是标记-清除算法，会产生内存碎片，严重时会导致Full GC。

### Garbage First收集器

不想写了。我是懒狗



## 类加载机制

**含义：**JVM将类的数据从Class文件加载到内存，对数据进行校验，初始化，最后形成能被JVM加载的Java类型的过程，就是类加载。

过程：**加载->验证->准备>>解析->初始化->使用->卸载**

![image](https://tvax4.sinaimg.cn/large/0085EwgIly1goobdj2cp7j30qw0a8jtu.jpg)

### 类加载的过程

#### 加载

>任务：
>
>1.通过类的全限定名来**获取类的二进制字节流**
>
>2.将**字节流代表的静态存储结构**，**转成方法区中的数据结构**
>
>3.在内存中生成java.lang.Class对象，是方法区的各种数据的访问入口

#### 验证

确保Class文件的字节流是否符合约束要求，保证代码运行后不会危害虚拟机的安全

#### 准备

为类中的**变量分配内存**，并对其进行**初始化**。

#### 解析

将**常量池中的符号引用**改成**直接引用**。

目的：能直接指向目标，或者定位到目标。

#### 初始化

初始化阶段就是执行类构造器()方法的过程。

具体内容待补充。为什么？因为我是懒狗 ：）

### 类加载器

类加载器，就是要完成上面所提到的加载过程：通过类的全限定名，将其转成二进制字节流。

#### 双亲委派模型

![image](https://tvax4.sinaimg.cn/large/0085EwgIly1goocd38moij30fo0e7n02.jpg)

**双亲委派模型的加载过程：**当一个类加载器收到类加载的请求，它不会马上继续类加载，而是委派更上层的类加载器去完成加载请求，直到传到顶层的启动类加载器。如果父加载器无法完成请求，他才会自己去加载请求。

**优点：**

>​	将java的类赋予了层级关系，从而使得java库中的类不管怎么加载都是唯一的。(意思就是说，比如Object类最终一定要进入到启动类加载器进行加载，保证了不同加载器的Object类是唯一的。如果不使用双亲委派模型，用户自己编写Object类，这时候不进入到启动类加载器进行加载，得到的Object类就是千奇百怪，那么原生的功能就无法使用了)

