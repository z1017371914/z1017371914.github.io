<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [类加载过程](#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)
  - [加载](#%E5%8A%A0%E8%BD%BD)
  - [验证](#%E9%AA%8C%E8%AF%81)
    - [文件格式验证](#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81)
    - [元数据校验](#%E5%85%83%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C)
    - [字节码验证](#%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81)
    - [符号引用验证](#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81)
  - [准备](#%E5%87%86%E5%A4%87)
  - [解析](#%E8%A7%A3%E6%9E%90)
    - [符号引用](#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8)
    - [直接引用](#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8)
    - [符号引用解析缓存](#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E8%A7%A3%E6%9E%90%E7%BC%93%E5%AD%98)
    - [类或接口的解析](#%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A7%A3%E6%9E%90)
    - [字段解析](#%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90)
    - [类方法解析](#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90)
    - [接口方法解析](#%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90)
  - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96)
    - [<clinit>()方法执行细节](#clinit%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%BB%86%E8%8A%82)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 类加载过程

Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化5个阶段锁执行的具体动作。

## 加载

“加载”是“类加载”过程的一个阶段。在加载阶段，虚拟机需要完成以下3件事情：

- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构
- 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

其中在读取类的二进制字节流上，我们可以有多种选择，我们可以从网络上、zip包等方式。

## 验证

验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体来说，虚拟机会通过以下4个阶段来进行Class文件字节流的校验。

### 文件格式验证

这个阶段会验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。这一阶段的验证点可能包括：

- 是否以魔数`0xCAFEBABE`开头
- 主、次版本号是否在当前虚拟机处理范围之内
……

这一阶段的验证是基于字节流的验证，只有当上述验证通过之后，字节流才会进入内存的方法去中进行存储。后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流

### 元数据校验

这一阶段将会对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：

- 这个类是否有父类（除了`java.lang.Object`之外，所有的类都应该有父类）
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
……

### 字节码验证

这一阶段是整个验证过程最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的时间，如：

- 博癌症任意时刻操作数栈的数据累心关于指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
- 保证跳转指令不会跳转到方法体以外的字节码指令上

如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的。但如果一个累方法体的字节码通过了字节码验证，也不能说明其一定就是安全的。这涉及到了离散数学中一个著名的问题”Halting Problem”。

### 符号引用验证

这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性验证，通常需要校验下列内容：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符以及简单名称锁描述的方法和字段
……

## 准备

准备阶段是正是为类变量分配并设置类变量初始值的阶段，这些变量锁使用的内存都将在方法去中进行分配。在这个阶段有两个比较容易混淆的概念需要强调一下：

- 这个阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将在对象初始化的时候随着对象一起分配在Java堆中。
- 这里说的初始化“通常情况”下是数据类型的零值，假设一个类变量的定义为：`pulibc static int value = 123;`，那么变量value在准备阶段过后的初始值为0而不是123。这时因为这时候从未执行任何方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。

下表列出了Java中所有基本数据类型的零值。

|数据类型|零值|数据类型|零值|
|---|---|---|---|
|int|0|boolean|false|
|long|0L|float|0.0f|
|short|(short)0|double|0.0d|
|char|'\u0000'|reference|null|
|byte|(byte)0|||

但是如果变了被`static final`声明称成常量，如下：

```java
public static final int value = 123;
```

那么在编译时javac会为value生成ConstantValue值，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量类型。

### 符号引用

符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。符号引用就是前面说过的CONSTANT_Class_info、CONSTATN_Field_info、CONSTANT_Methodref_into等类型的常量。

### 直接引用

直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

虚拟机规范并未规定解析阶段发生的时间，只要求了在执行`anewarray、checkcast、getfield、getstatic、instance、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、1dc、1dc_w、multianewarray、new、putield和putstatic这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机可以根据实际情况判断是要在类被加载器加载的时候就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前采取解析它。

### 符号引用解析缓存

对于同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令之外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接一弄，并把常量标识为已解析状态）从而避免解析动作重复进行。

之所以对于invokedynamic指令上面规则不城里，是因为invokedynamic指令的目的本来就是用于动态语言支持，这里的动态指的是必须等到程序实际运行到这条指令的时候，解析动作才能进行。

### 类或接口的解析

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：

- 1）如果C不是一个数组类型，那虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、直接骂验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。

- 2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符回事类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数据元素类型。如果N的描述符如前面锁假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。

- 3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将跑出`java.lang.IllegalAccessError`异常。

### 字段解析

要解析一个字段，首先得先找到这个字段所属的类。所以首先会从字段表中的class_index项中找出CONSTANT_Class_info符号引用进行解析，找出字段所属的类或接口。在解析这个类或接口的过程中出现了任何异常，都会导致字段符号引用解析失败。如果成功完成，那么僵这个字段所属类或接口用C来表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：

- 1）如果C本身包含了简单名称和字段描述符都与目标想匹配的字段，则返回这个字段的直接引用，查找结束。
- 2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
- 3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果类中包含了简单名称和字段描述符与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
- 4）否则，查找失败，抛出`java.lang.NoSuchFieldError`异常。

总而言之，简单地说，其查找路径就是：本类->父类->父接口。如果查找成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出`java.lang.IllegalAccessError`异常。

### 类方法解析

类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机会按照如下步骤进行后续的类方法搜索。

- 1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法中发现class_index中索引的C是个接口，那就直接抛出`java.lang.IncompatibleClassChangeError`异常。
- 2）如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
- 3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
- 4）否则在类C实现的接口列表及它们的父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出`java.lang.AbstractMethodError`异常。
- 5）否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`。

简单地说，其查找路径就是：本类->父类->父接口。如果查找成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对字段的访问权限，将抛出`java.lang.IllegalAccessError`异常。

### 接口方法解析

接口方法也需要先解析出类方法表的class_index项中索引的方法所属的类或接口符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机会按照如下步骤进行后续的接口方法搜索。

- 1）与类方法解析不同，如果在接口方法表中发现class_index中索引的C是是个类而不是接口，那就直接抛出`java.lang.IncompatibleClassChangeError`异常。
- 2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
- 3）否则，在接口C的父接口中递归查找，知道`java.lang.Object`为止（包括Object类），看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
- 4）否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`。

简单地说，其查找路径就是：本接口->父接口。由于接口中所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出`java.lang.IllegalAccessError`。

## 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作都由虚拟机控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

在准备阶段，变量已经赋过一次系统要求的初始化，而子啊初始化阶段，则根据程序员通过程序制定的主管计划去初始化类变量和其他资源，或者从另外一个角度来表达：初始化阶段是执行类狗在其`<clinit>()`方法的过程。

### <clinit>()方法执行细节

- <clinit>()方法是由编译器自动收集类中所有类变量的复制动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。静态语句块只能范文到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。

```java
public class Test{
	static{
		i = 0;   //给变量赋值可以正常编译通过
		System.out.print(i);  //这句编译器会提示：“非法向前引用”
	}
	static int i = 1;
}
```

- <clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是`java.lang.Object`。

- 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。在下面的代码中，字段B的值将会是2而不是1。

```java
static class Parent{
	public static int A = 1;
	static{
		A = 2;
	}
}

static class Sub extends Parent{
	public static int B = A;
}

public static void main(String args[]){
	System.out.println(Sub.B);
}
```

- <clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法的过程。

- 接口中不能使用静态语句块，但是可以有变量初始化操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要限制性父接口中的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。

- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地枷锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程会执行类的<clinit>()方法，其他线程都会阻塞等待。




