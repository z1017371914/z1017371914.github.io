<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [虚拟机字节码执行引擎](#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E)
  - [运行时栈帧结构](#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84)
    - [局部变量表](#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8)
    - [操作数栈](#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88)
    - [动态连接](#%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5)
    - [方法返回地址](#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 虚拟机字节码执行引擎

在所有虚拟机实现里面，字节码执行引擎在执行Java代码的时候都有两种执行方式：解释执行、编译执行。有时可能单独只用一种，有时候两者兼备。虽然有时候选择的执行方式不同，但是Java虚拟机都是输入字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 运行时栈帧结构

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈的栈元素，一般来说，其存储了局部变量表、操作数栈、动态连接、方法返回地址等信息。

一个线程的方法调用链可能会很长，很多方法都同时处于执行状态。但对于执行引擎来说，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。

### 局部变量表

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽为最小单位，虚拟机规范中建议每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或者更小的物理内存来存放。而对于64位的数据类型，虚拟基金会以高位对齐的方式为其分配两个连续的Slot空间。

在局部变量表里，每一个局部变量表第0位索引的Slot默认用于传递方法所属对象实例的引用，在方法中可以通过this来访问到这个隐藏的参数。而为了节省空间局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。

### 操作数栈

操作数栈也常称为操作栈，它是一个后进先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈中的每一个元素都可以是任意的Java数据类型，包括long和double。32位数据类型占用的栈容量为1，64位数据类型所占用的栈容量为2。

### 动态连接

每个栈帧都包括了一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。有些方法引用在类加载阶段或第一次使用的时候就转化为直接引用，但有些引用在每一次运行期间转化为直接引用，这部分称为动态连接。

### 方法返回地址

当一个方法开始的时候，一般会有两种情况会导致方法结束。一种情况是执行引擎遇到任意一个方法返回的字节码指令，这时候会根据字节码指令的不同，返回不同的返回值和返回类型给调用者，这种退出方式称为正常完成出口。另一种情况是在方法执行过程中遇到了异常，并且这个异常在方法体中没有得到处理，这时候会导致方法退出，这种退出方式称为异常完成出口。

