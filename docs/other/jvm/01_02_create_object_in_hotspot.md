<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [HotSpot虚拟机对象](#hotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1)
  - [空间分配](#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D)
  - [内存空间初始化](#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96)
  - [对象设置](#%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE)
  - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96)
  - [对象的内存布局](#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80)
    - [对象头](#%E5%AF%B9%E8%B1%A1%E5%A4%B4)
    - [实例数据](#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE)
    - [对齐填充](#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85)
  - [对象的访问定位](#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# HotSpot虚拟机对象

一个对象在JVM中从编译到创建完成需要经历很多过程，大概可以分为：空间分配、内存空间初始化、对象设置、初始化。

## 空间分配

虚拟机遇到一条new指令时，接下来虚拟机将为新生对象分配内存。不同垃圾回收器的分配方式不同，大致可以分为**指针碰撞**和**空闲列表**两种方式。

**指针碰撞**

指针碰撞指的是Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空编的内存放在一边，中间放着一个指针作为分界点的指示器，那分配内存时就是把指示器挪动一段与对象大小相等的距离。Serial垃圾回收器和ParNew垃圾回收期使用的就是这种空间分配方式。

**空闲列表**

空闲列表指的是内存区域不是绝对规整的，虚拟机维护着一个列表，记录上哪些内存是可用的，分配的时候就从列表中寻找一块足够大的空间划分给对象实例，并更新列表上的记录。CMS垃圾回收器使用的就是这种空间分配方式。

但内存分配是非常频繁的行为，有可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决内存分配的并发性问题一般有两种方案，即：**CAS失败重试**和**TLAB本地线程分配缓冲**。

**CAS失败重试**

CAS失败重试指的是在给对象A分配内存时，先修改内存地址，在修改内存地址之时比较内存地址的值是否与传进来的原内存地址值相同，如果相同，那么说明在这个过程中没有其他线程修改过，可以进行线程分配，否则需要重新尝试修改内存地址。

我们可以用一个Java方法来描述这个算法：

```java
main(){
   while(true){
   		if(compareAndSet(originAddr, targetAddr) == targetAddr){
   			break;
   		}
   }
}
int compareAndSet(int originAddr, int targetAddr){
	int nowAddr = get();  //获取现在的内存地址值
	if(nowAddr == originAddr){
		set(targetAddr);
		return targetAddr
	}
	return originAddr
}
```

**TLAB本地线程分配缓冲**

每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（TLAB），哪个线程需要分配内存，先在TLAB中分配内存，只有TLAB用完并分配新的TLAB时，才需要同步锁定。

## 内存空间初始化

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值，这一步保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值，如int类型默认值为0。

## 对象设置

接下来虚拟机会设置对象的一些必要信息，如：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GB分代年龄等信息。这些信息都会存放在对象的“对象头”中。

## 初始化
   
当上面所有的工作都完成后，对于虚拟机来说一个对象就产生了，但是站在程序的角度看，对象创建才刚刚开始，对象的构造方法还未执行，所有字段都还为零。所以这一步会执行对象的构造方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算创建完成。

## 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。

### 对象头

对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如：哈希码、GC分代年龄、锁状态标识等。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

### 实例数据

这部分是对象真正存储的有效信息，无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。

### 对齐填充

因为HotSpot的自动内存管理要求对象起始地址必须是8字节的整数倍，而对象头部分刚好是8字节的整数倍，所以当实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 对象的访问定位

创建了对象就是为了使用对象，我们的Java程序需要通过栈上的reference指针来操作堆上的具体对象。目前主流的访问方式有使用**句柄**和**直接指针**两种方式。

**句柄**

使用句柄访问，那么Java堆中就需要划出一块区域来作为句柄池，reference中存储的就是对象的句柄地址，而句柄地址中包含了对象实例数据和对象类型数据。

**直接访问**

如果使用直接指针访问，那么reference中存储的就是对象地址，而Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息。
   
   

