<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [垃圾回收](#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
  - [可达性算法](#%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95)
    - [引用计数器](#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8)
    - [GC Roots](#gc-roots)
  - [垃圾回收算法](#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95)
    - [标记-清除算法](#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95)
    - [复制算法](#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95)
    - [标记-整理算法](#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 垃圾回收

在Java中垃圾回收是JVM自身实现的一个动作，不需要我们去手动进行垃圾回收。但如果编写程序不当，Java程序也还是会发生内存溢出问题。要避免Java程序发生内存溢出问题，就必须要了解JVM进行垃圾回收的细节。

任何虚拟机进行垃圾回收时，都会考虑两个问题：

- 如何判断一个对象是否应该被回收？
- 如何回收一个对象？

## 可达性算法

可达性算法是用于判断一个对象是否应该被回收的算法。它的根本原理是判断这个对象到底还有没有其他人使用，如果该对象没有人使用了，那么该对象就会应该被回收。

可达性算法目前有两种常见的实现方式：**引用计数器**和**GC Roots**。

### 引用计数器

引用计数器指的是在对象里存储了一个计数器，这个计数器表示对象被其他对象引用的次数。当有对象增加对其的引用时，计数器值加一。当有对象移除对其引用时，计数器值减一。进行垃圾回收时，垃圾回收器扫描内存中所有的对象，判断其计数器是否为零，如果为零则表示该对象应该被回收。

但引用计数器存在一个循环引用的问题，也就是说存在A引用B，B引用C，C引用A的问题，也即ABC三个对象循环引用，但没有任何一个对象引用了ABC。它们的计数器虽然不为零，但它们却无法被程序使用。

### GC Roots

GC Roots 指的是使用一些根集合对象作为出发点，不断地遍历这些根集合对象的引用，形成一条引用链，所有在这条引用链上的对象都是存活的，而不在这条引用你链上的对象则是应该被回收的。

在这个实现方式中，最重要的就是如何寻找根集合对象了。在Java语言中，可作为根集合对象的包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）引用的对象

例如当程序运行到下面hello()方法时，hello()方法中的str变量属于本地变量，因此其引用的String对象可以作为GC Roots，类中的静态NAME属性属于方法区中类静态属性引用的对象，其引用的String对象也可以作为GC Roots。

```java
public class GCRoots{
	public static String NAME = new String("hello");
	public void hello(){
		String str = new String();
		System.out.println(str);	
	}
}
```

因为引用计数器存在循环引用的问题，所以现在大多数虚拟机都采用了GC Roots方式来实现对象的可达性算法。

## 垃圾回收算法

当垃圾回收器通过GC Roots方式找到了应该被回收的对象后，下一步就应该是将对象回收。垃圾回收有三种常见的算法：**标记-清除算法**、**复制算法**、**标记-整理算法**。

### 标记-清除算法

“标记-清除”算法是最基础的算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记处出所有需要回收的对象，在标记完成之后统一回收所有需要回收的对象。之所以说它是最基础的算法，是因为之后的其他算法都是基于这种思路并对其不足进行改进而得到的。

它的不足主要有两个：一个是效率问题，标记和清除两个过程的效率并不高。另一个是空间问题，标记清除后会产生大量的不连续的内存碎片，空间内存碎片太多后会导致在分配大对象的时候回因为无法找到足够大的连续内存空间而不得不提前促发一次垃圾收集动作。

![](../img/03/03_01_mark_sweep.png)

### 复制算法

“复制”算法指的是将内存划分为均等的两块，其可用的内存空间仅为原来的1/2。当垃圾回收器进行垃圾回收时，将内存中存活的对象直接复制到另外一块内存空间中，之后直接对原来的内存空间进行清除操作。

这种算法虽然可以很快地完成内存清除的任务，并且也保证了连续的大块内存空间，但是其代价是牺牲了一半的内存空间。

虚拟机的新生代垃圾回收算法是采用复制算法进行垃圾回收的，但是其采用的复制算法是在深度研究之后进行改进的。根据IBM公司的研究表明，在新生代中的对象98%是朝生夕死的，所以并不需要按照1：1的比例来划分内存空间。所以在HotSpot虚拟机中，JVM将内存划分为一块较大的Eden空间和两块较小的Survivor空间，其大小占比是8：1：1。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Eden空间。

通过这种方式，内存的空间利用率达到了90%，只有10%的空间是浪费掉了。当超过10%的对象存活的时候，Survivor空间将不够用，这时候需要依赖其他内存（这里指老年代）进行分配担保。具体的内存分配策略会在后面的章节中讲到，这里暂不深入。

![](../img/03/03_02_copy.png)

在这里我们思考几个问题：

- 为什么复制算法一开始是一半分配，一半做备份？

这个问题虽然很傻，但是还是可以思考一下。复制算法的本质是用一块内存作为转运中心，用于存放存活对象，便于对另外一块内存空间做清除操作。之所以一半一半分开，是因为当在进行对象复制时，对象复制的极端情况是100%的对象都存活，那么要将所有对象都复制过去，就必须要求两边的内存大小都相等。

- 那为什么HotSpot虚拟机采用的是8：1：1的划分方式？不能直接一块Eden内存，一块Survivor就好了？

这个问题其实可以分为几个问题。**第一：为什么Eden空间要分配80%的大小？**这个其实很好解释。根据IBM研究的统计数据表明，大多数情况下98%的内存都讲被回收，也就是只有2%的存活对象。如果按照1：1划分内存，那么将50%的内存用于存放2%的对象，是极大的一种浪费。于是才将Eden空间分配了80%的大小。**第二：为什么是两块Survivor内存，而不是一块Survivor内存？**事实上，因为复制算法的核心是需要一个中转块来存放存活的对象，所以如果只有一块Survivor内存，那么在进行内存回收的时候将无法将原先Survivor内存中的存活对象复制并清除。想象一下，如果只有一块Survivor内存，当进行第一次垃圾回收时，Survivor内存是空的，Eden内存中的存活对象复制到了Survivor对象中，Eden内存清空。第二次垃圾回收时，Eden中存活的对象继续复制到原来的Survivor对象中（此时Survivor对象不是空的）。垃圾回收器发现Survivor内存中也有需要回收的对象，这时候Survivor中的存活对象复制到哪里呢？所以这就是为什么需要使用两块Survivor空间的原因。这有点类似于两个变量值交换，必须还要有一个变量作为空中间量的算法。

### 标记-整理算法

“标记-整理算法”指的是在标记之后，将存活的对象都向一端移动，然后直接清理掉边界以外的内存。

![](../img/03/03_02_mark_compact.png)

