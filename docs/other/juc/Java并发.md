

## 并发编程的挑战

并发编程性能所遇到的一些挑战：**上下文切换**，**死锁**，**软硬件资源**

### 上下文切换

`上下文切换`：保存上文的内容，切换到下文的内容。常见的有CPU上下文切换，进程上下文切换，线程上下文切换。

1.并发需要进行多次上下文切换，如果任务数比较少，那么并发并不比串行效率高

2.并发需要`创建线程`，`线程切换`，也非常耗时。

3.减少上下文切换的方法：

>①`无锁并发编程`：不同的线程通过HashID来处理不同的数据，线程之间不干扰。
>
>②`CAS算法`：Compare And Swap，更新数据只需要对比，而不需要加锁
>
>③`使用最少线程`：避免使用过多的线程，让很多线程处于等待状态
>
>④`协程`：单线程中实现多任务的调度，携程切换没有线程切换的开销大。

### 死锁

1.`死锁`形成的四个条件:`请求与保持`,`资源互斥`,`不剥夺原则`,`循环等待`.

2.多个线程对资源上锁以及请求资源，很容易形成死锁，造成服务的崩溃。

### 资源限制的挑战

1.`资源限制`：机器的下载带宽为1MB/s，开启十个线程是不可能将下载带宽变成10MB/s的。

2.硬件资源：单机硬件资源不足，那么可使用分布式集群，通过负载均衡来分发任务，提高系统吞吐量

3.软件资源：软件资源不足，可复用而不是立即释放，例如线程池的思想

## 并发的底层实现

### volatile

1.`volatile`：实现**数据的可见性**(修改某一个值，对其他线程，进程，CPU是可见的)。

2.底层实现：被修饰的变量在写入前，其汇编代码加上了一个lock指令。

3.lock指令的作用：

>因为追求性能，CPU大部分时间和Cache打交道，数据会缓存在Cache中。要实现修改的可见性，就首先要让其他Cache缓存失效，并且修改的值写入到内存中。
>
>①CPU1修改了变量的值，强制将修改后的数据从CPU1的`cache`写入到`内存`中
>
>②写回内存的操作会让其他缓存了该数据的CPU中Cache数据失效(具体实现：`缓存一致性协议`:每个CPU会在数据总线上嗅探自己缓存的数据的地址是否被修改，如果已经修改，那么将Cache中该数据标记为失效，下次读取该数据就需要从内存中读取)

### synchronized

1.`synchronized`：以前是重量级锁，通过引入`偏向锁`，`轻量级锁`后，减少了获得锁和释放锁的性能开销.

2.作用对象：

>①修饰`普通方法`：锁住`对象实例`
>
>②修饰`静态方法`：锁住`所在的类`
>
>③修饰`方法块`：锁住`方法块里有的所有对象`

3.底层实现：使用`monitorenter`和`monitorexit`两个指令来实现。

4.实现过程：monitorenter和monitorexit需要`成对`的出现。执行monitorenter就会**获取对象的所有资源**；执行monitorexit就会**释放对象的所有资源**

5.synchronized使用的锁存在`Java对象头`中的`Mark Word`里面。

### 锁的升级

1.Java SE1.6中，锁按级别从低到高分别是`无锁`，`偏向锁`，`轻量级锁`，`重量级锁`.

2.锁的原则：可以升级，但**不可降级**。

#### 偏向锁

1.出现的原因：多线程竞争资源的情况很少，大多数情况是**单线程不断的重复获取资源**。为了**减少线程获得锁的开销**，引入了`偏向锁`

2.关于偏向锁的信息，是存在对象头中的`Mark Word`和线程栈帧的`锁记录`。

3.`偏向锁加锁`：当一个线程访问代码块时，会在对象头和栈帧中记录该`线程的ID`，表明该线程已获得该对象的偏向锁。当线程再尝试访问该代码块时，只需要**检查对象头中的Mark Word是否有该线程ID**，而不是直接通过CAS来竞争锁。

>如果存在线程ID，则直接让线程访问该同步代码块；
>
>如果不存在，需要检查Mark Word中的锁是否为偏向锁。(如果是，那就尝试使用CAS操作将Mark Word中的线程ID更新为当前线程ID；如果不是，则使用CAS竞争锁)

4.`偏向锁的撤销`:需要在`全局安全点`(没有正在执行的字节码)才能撤销。

>①暂停所有拥有偏向锁的线程
>
>②查看这些线程是否存活。如果不存活，直接将对象头中的Mark Word标记为无锁状态
>
>③如果存活，遍历偏向对象的锁记录，栈中的锁记录**要么偏向其他线程**，**要么恢复到无锁**，要**么标记为不适合偏向锁**

#### 轻量级锁

1.`轻量级锁`的相关信息，需要线程在自己的栈帧(线程私有的空间)中开辟空间进行存储。

2.`轻量级锁的加锁`：

>①将对象头的Mark Word复制到锁记录，也称为`Displaced Mark Word`
>
>②线程尝试使用CAS操作，将**对象头的Mark Work替换为指向自己锁记录的指针**
>
>③如果成功，那么线程获得轻量级锁
>
>④如果失败，那么线程将`自旋`来获得锁

3.`轻量级锁的撤销`:

>①线程A尝试原子的CAS操作，将对象头中Mark Word的内容写成自己栈帧中的锁记录内容
>
>②如果成功，说明无锁竞争，成功释放锁。
>
>③如果失败，说明有锁竞争，那么线程A`自旋`等待获得锁。
>
>④线程A自旋超时，**膨胀成重量级锁**，处于阻塞状态。
>
>⑤拥有锁拥有权的线程B发现自己CAS操作失败，也察觉到有锁竞争，于是释放锁，唤醒线程A
>
>⑥线程A获得锁拥有权，执行完后按①那样释放锁。

4.个人理解：本质上来说，轻量级锁将对象的Mark Word存入自己的锁记录指针，从而使得自己能拥有锁。当撤销的是否就将Mark Word的内容从指针还原成锁记录的内容。如果失败，那么就会升级称重量级锁，阻塞等待拥有该锁的其他线程通过释放锁来唤醒自己。一直这样往复，直到锁完全释放。

#### 重量级锁

![image](https://tva2.sinaimg.cn/large/0085EwgIgy1goqbrnm411j30oh06ujub.jpg)

 ### 原子操作

1.Java首先原子操作的方式有`CAS`和`锁`.锁就是上面提到的，不多叙述。

2.`CAS`操作：Compare And Swap

#### CAS可能的问题

1.`ABA问题`

**问题描述：**CAS是通过对比改动前后的值是否发生了变化。比如变量x**改动前值为A**，如果需要改动时x当前值仍未A，就认为x没有被修改过。但是有可能有其他线程对x进行了修改：A->B->A.就比如你走之前有一杯雪碧是满的，回家之后还是满的，但如果是有人投喝然后装了白开水，你是无法感知到的。

**解决方法：**除了记录修改前的值，还记录版本号。每个线程修改时都要更新变量的版本号。这样CAS就需要对比两个属性：`值`和`版本号`

2. `自旋CAS开销大`

**问题描述：**相当于while(true)一样不断去尝试获取修改，对CPU的负担很大。

**解决方法：**自旋的时候使用PAUSE指令。

> PAUSE指令的作用：
>
> ①延迟CPU执行流水线的时间。从而减轻CPU的负担
>
> ②避免出现`内存顺序冲突`(多个CPU操作一个缓存行的不用部分而引起某个CPU操作失败，进而清空流水线)而清空掉流水线

3.`只能保证单个共享变量的原子性`

解决方法：将多个共享变量放入一个对象里来实现原子操作。

