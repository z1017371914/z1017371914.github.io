

## 343.整数拆分

问题：

>
>
>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
>
>示例 1:
>
>输入: 2
>输出: 1
>解释: 2 = 1 + 1, 1 × 1 = 1。
>示例 2:
>
>输入: 10
>输出: 36
>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

### 思路：动态规划/数学推导

#### 动态规划

##### 代码

```java
class Solution {
    //动态规划
    public int integerBreak(int n) {
        //存储0到n的每个结果。dp[i]表示第i个数的结果。这么动态规划下去，第n个就是结果
        int[] dp = new int[n+1];
        //0和1不拆分，因此置为0
        dp[0] = 0;
        dp[1] = 0;
        for ( int i = 2; i < dp.length; i++ ) {
            for ( int j = i - 1; j > 0; j-- ) {
                //第i个数的结果，无非是两种情况：要么是dp[j]再乘以i-j
                //要么是第一种情况中，dp[j]不需要拆分了，直接用j*(i-j)
                //通俗来说，比如i= 10，j = 7
                //那么dp[10] 应当是dp[7]*(10-7)或者7*(10-7)中的最大值
                dp[i] = Math.max(dp[i], dp[j]*(i-j));
                dp[i] = Math.max(dp[i],j*(i-j));
            }
        }
        return dp[n];
    }
}
```

#### 数学推导

数论：一个数尽可能地将和凑出3的个数最多时，乘积就会是最大。

##### 代码

```java
class Solution {
    //尽量构造出3的次数最多，很简单，用n/3，就能得到log3n的向下取整的值，就不用对数运算了
    public int integerBreak(int n) {
        if ( n < 1 ) return 0;
        if ( n == 2 ) return 1;
        if ( n == 3 ) return 2;
        int a = n / 3, b = n % 3;
        //找到3的最大次数后，要对余数进行分类处理：
        //余数为0，直接返回3的a次方
        //余数为1，那么应该返回3的a-1次方乘以4，因为他会比3的a次方乘以1要大
        //余数为2，直接返回3的a次方乘以2
        if ( b == 0 ) return (int)Math.pow(3, a);
        if ( b == 1 ) return (int)Math.pow(3, a - 1) * 4;
        if ( b == 2 ) return (int)Math.pow(3, a) * 2;
        return 0;
    }
}
```

## 121.买卖股票的最佳时机

>问题：
>
>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
>
>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
>
> 
>
>示例 1：
>
>输入：[7,1,5,3,6,4]
>输出：5
>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
>示例 2：
>
>输入：prices = [7,6,4,3,1]
>输出：0
>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
>
>
>提示：
>
>1 <= prices.length <= 105
>0 <= prices[i] <= 104

### 思路：动态规划

>使用动态规划，最大利润要么是之前的利润，要么是今天卖出获得的利润。
>
>那么，我们就要维护这两个东西：
>
>>1.之前位置的最大利润
>>
>>2.当前日之前的最低买入价格。这样才能实现当日减掉最小的买入价格，从而实现最大利润。

#### 代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        //动态规划，不断维护当前元素位置往前的最小值，以及当天卖出的利润。
        int min = Integer.MAX_VALUE;
        int profit = 0;
        for ( int i = 0; i < prices.length; i++ ) {
            //维护当前元素位置之前的最小值
            min = Math.min(min, prices[i]);
            //维护利润，要么是之前的最大值，要么是当天减掉之前的最小值
            profit = Math.max(profit, prices[i] - min);
        } 
        return profit;
    }
}
```

## 122.买卖股票的最佳时机II

>问题：
>
>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> 
>
>示例 1:
>
>输入: [7,1,5,3,6,4]
>输出: 7
>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
>示例 2:
>
>输入: [1,2,3,4,5]
>输出: 4
>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>示例 3:
>
>输入: [7,6,4,3,1]
>输出: 0
>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>
>
>提示：
>
>1 <= prices.length <= 3 * 10 ^ 4
>0 <= prices[i] <= 10 ^ 4

### 思路：贪心算法

#### 代码

```java
class Solution {
    //贪心算法。相隔的计算利润后累加。
    //维护一个当前元素之前的最小购买值
    //如果当前元素大于，那么就计算利润后加入，然后将min置为当前元素
    //相当于 1, 5, 6
    // profit = ( 5 - 1) + (6 -5 )
    //这样就避免了判断是否需要卖出，也就是只要获利就卖出
    public int maxProfit(int[] prices) {
        int profit = 0;
        int min = prices[0];
        for ( int i = 0; i < prices.length; i++ ) {
            if ( prices[i] > min ) {
                profit += prices[i] - min;
                min = prices[i];
            } else {
                min = prices[i];
            }
        }
        return profit;
    }
}
```

## 198.打家劫舍

>问题：
>
>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> 
>
>示例 1：
>
>输入：[1,2,3,1]
>输出：4
>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>     偷窃到的最高金额 = 1 + 3 = 4 。
>示例 2：
>
>输入：[2,7,9,3,1]
>输出：12
>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
>
>
>提示：
>
>0 <= nums.length <= 100
>0 <= nums[i] <= 400

### 思路：动态规划

>递推公式： dp[i]  = Math.max(dp[i - 1], dp[i - 2] + nums[current])
>
>关键是处理好数组的索引即可

#### 代码

```java
class Solution {
    public int rob(int[] nums) {
        if ( nums.length == 1 ) {
            return nums[0];
        } 
        if ( nums.length == 2 ) {
            return Math.max(nums[0], nums[1]);
        }
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        for ( int i = 2; i < dp.length; i++ ) {
            dp[i] = Math.max(dp[i - 1], dp[i -2] + nums[i - 1] );
        }
        return dp[dp.length - 1]; 
    }
}
```



## 213.打家劫舍II

>问题：
>
>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。
>
> 
>
>示例 1：
>
>输入：nums = [2,3,2]
>输出：3
>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
>示例 2：
>
>输入：nums = [1,2,3,1]
>输出：4
>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>     偷窃到的最高金额 = 1 + 3 = 4 。
>示例 3：
>
>输入：nums = [0]
>输出：0
>
>
>提示：
>
>1 <= nums.length <= 100
>0 <= nums[i] <= 1000

### 思路

>由于首尾相接，那么头和尾只能二选一，所以只需要求从 0到n-2和1到n-1，然后取最大值即可。

#### 代码

```java
class Solution {
    public int rob(int[] nums) {
        if ( nums.length == 1 ) {
            return nums[0];
        }
        if ( nums.length == 2 ) {
            return Math.max(nums[0], nums[1]);
        }
        //取0~n-2和1~n-1中的最大值
        return Math.max(findMax(nums, 0, nums.length - 2), findMax(nums, 1, nums.length - 1));
    }
	
    //动态规划找出某区间内的符合条件的最大值，由于通过参数传入，所以不用考虑首尾相接。
    public int findMax ( int[] nums, int start, int end ) {
        //多出两个元素。dp[0]用来确定dp[2]。
        //dp[1]肯定是等于nums的以一个元素。所以dp[1]=nums[start]
        int[] dp = new int[end - start + 2];
        dp[0] = 0;
        dp[1] = nums[start];
        for ( int i = 2; i < dp.length; i++ ) {
            //当前值的最大值，要么是前一个值dp[i-1]，要么是dp[i-2](前两个的值)加上当前索引对应数组中的值。
            //和i对应的数组索引为start+i-1.
           //例如：当i=2，dp[2] = Math.max(dp[1], dp[0] + nums[????] )
            //很明显nums的索引需要是传入的数组中的第2个数，即nums[1+start].将start认为是0，
            //因为它是传入的数组的开始元素。但是每次都要递增1，比如dp[3]的时候需要用的数组索引是2，
            //那就应该想办法构造，使得？？？？是以start+1+1+1递增下去
            //所以i=2时，我们取1，i=3时我们取2，很明显就是i-1。再加上start保证开始的索引是正确的
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[start + i - 1]);
        }
        return dp[dp.length - 1];
    }
}
```

