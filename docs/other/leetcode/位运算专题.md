

## 78.子集

>
>
>问题：
>
>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
>
>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
>
> 
>
>示例 1：
>
>输入：nums = [1,2,3]
>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
>示例 2：
>
>输入：nums = [0]
>输出：[[],[0]]
>
>
>提示：
>
>1 <= nums.length <= 10
>-10 <= nums[i] <= 10
>nums 中的所有元素 互不相同

### 思路：位运算

>将数组的元素看成二进制数。0代表不需要加入，1代表需要加入。
>那么，需要遍历从0 ~ (2^n - 1),也就是 0 ~ (1 << nums.length) - 1
>每次遍历中，都要遍历数组，计算该索引的二进制位和当前遍历到的二进制位是否都是1
>是的话就加入到该次遍历中。

#### 代码

```java
class Solution {
    //将数组的元素看成二进制数。0代表不需要加入，1代表需要加入。
    //那么，需要遍历从0 ~ (2^n - 1),也就是 0 ~ (1 << nums.length) - 1
    //每次遍历中，都要遍历数组，计算该索引的二进制位和当前遍历到的二进制位是否都是1
    //是的话就加入到该次遍历中。
    //例如：遍历到 010，就需要遍历数组的所有元素：nums[0],nums[1],nums[2]
    //接着对索引进行判断：2^0 = 000, 000 & 010 = 0,就不能将nums[0]加入到这次遍历中
    // 2^1 = 010, 010 & 010 = 1,需要将nums[1]加入到这次遍历中
    // 2^2 = 100, 100 & 010 = 0,不能将num[2]加入到这次遍历中
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> temp = new ArrayList<>();
        for ( int i = 0; i < (1 << nums.length); i++ ) {
            temp.clear();
            for ( int j = 0; j < nums.length; j++ ) {
                if ( ((1 << j ) & i) != 0 ) {
                    temp.add(nums[j]);
                }
            }
            res.add(new ArrayList<Integer>(temp));
        }
        return res;
    }
}
```

## 50.Pow(x,n)

>
>
>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n）。
>
>示例 1：
>
>输入：x = 2.00000, n = 10
>输出：1024.00000
>示例 2：
>
>输入：x = 2.10000, n = 3
>输出：9.26100
>示例 3：
>
>输入：x = 2.00000, n = -2
>输出：0.25000
>解释：2-2 = 1/22 = 1/4 = 0.25
>
>
>提示：
>
>-100.0 < x < 100.0
>-231 <= n <= 231-1
>-104 <= x^n <= 104

### 思路：快速幂

>
>
>将n化为二进制的01形式，使用快速幂，将时间复杂度降低到O( log N)。
>
>例如 n = 10，也就是二进制的 1010；x = 2.
>
>2 ^ 10 = 2^(8+2) = (2^8) * (2^2)
>
>所以，只需要将n中为1的位数乘起来即可。

#### 代码

```java
class Solution {
    //快速幂，将时间复杂度降低到O(log n )。
    //算式中，x每次是这么变化的：x^2, x^4,x^8,x^16,x^32.....
    //不断让n除以2，就能得到n的从低位开始的每一位
    //让n和1按位取与，就能知道n的最右边一位是0还是1.
    //是1的话就让结果集合乘以当前的x。
    public double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2){
            if((i & 1) != 0){
                res *= x;
            }
            x *= x;
        }
        return  n < 0 ? 1 / res : res;
    }
}
```

